{"hash":"fe62f3bd8b16be1e","sourceSize":35907,"sourceSizeGzipped":12651,"compileTime":"28.084244ms","name":"datastar-0-20-0-fe62f3bd8b16be1e","downloadURL":"/bundler/download/datastar-0-20-0-fe62f3bd8b16be1e.zip","manifest":{"version":"0.20.0","plugins":[{"label":"delete","name":"DeleteSSE","path":"../plugins/official/actions/backend/sseDelete","type":"ACTION","author":"Delaney Gillilan","slug":"Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface","description":"Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.","icon":"material-symbols:delete","key":"static_library_source_plugins_official_actions_backend_sse_delete_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:delete\n// Slug: Use a DELETE request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const DeleteSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"delete\",\n    method: sendSSERequest(\"delete\"),\n};\n"},{"label":"get","name":"GetSSE","path":"../plugins/official/actions/backend/sseGet","type":"ACTION","author":"Delaney Gillilan","slug":"Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface","description":"Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.","icon":"ic:baseline-get-app","key":"static_library_source_plugins_official_actions_backend_sse_get_ts","contents":"// Authors: Delaney Gillilan\n// Icon: ic:baseline-get-app\n// Slug: Use a GET request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const GetSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"get\",\n    method: sendSSERequest(\"get\"),\n};\n"},{"label":"patch","name":"PatchSSE","path":"../plugins/official/actions/backend/ssePatch","type":"ACTION","author":"Delaney Gillilan","slug":"Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface","description":"Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.","icon":"mdi:bandage","key":"static_library_source_plugins_official_actions_backend_sse_patch_ts","contents":"// Authors: Delaney Gillilan\n// Icon: mdi:bandage\n// Slug: Use a PATCH request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PatchSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"patch\",\n    method: sendSSERequest(\"patch\"),\n};\n"},{"label":"post","name":"PostSSE","path":"../plugins/official/actions/backend/ssePost","type":"ACTION","author":"Delaney Gillilan","slug":"Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface","description":"Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.","icon":"material-symbols:add","key":"static_library_source_plugins_official_actions_backend_sse_post_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:add\n// Slug: Use a POST request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PostSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"post\",\n    method: sendSSERequest(\"post\"),\n};\n"},{"label":"put","name":"PutSSE","path":"../plugins/official/actions/backend/ssePut","type":"ACTION","author":"Delaney Gillilan","slug":"Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface","description":"Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.","icon":"material-symbols:find-replace","key":"static_library_source_plugins_official_actions_backend_sse_put_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:find-replace\n// Slug: Use a PUT request to fetch data from a server using Server-Sent Events matching the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { sendSSERequest } from \"./sseShared\";\n\nexport const PutSSE: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"put\",\n    method: sendSSERequest(\"put\"),\n};\n"},{"label":"clipboard","name":"Clipboard","path":"../plugins/official/actions/dom/clipboard","type":"ACTION","author":"Delaney Gillilan","slug":"Copy text to the clipboard","description":"This action copies text to the clipboard using the Clipboard API.","icon":"mdi:clipboard","key":"static_library_source_plugins_official_actions_dom_clipboard_ts","contents":"// Authors: Delaney Gillilan\n// Icon: mdi:clipboard\n// Slug: Copy text to the clipboard\n// Description: This action copies text to the clipboard using the Clipboard API.\n\nimport { ActionPlugin } from \"../../../../engine\";\nimport { ERR_NOT_ALLOWED } from \"../../../../engine/errors\";\n\nexport const Clipboard: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clipboard\",\n    method: (_, text) =\u003e {\n        if (!navigator.clipboard) {\n            // Clipboard API not available\n            throw ERR_NOT_ALLOWED;\n        }\n        navigator.clipboard.writeText(text);\n    },\n};\n"},{"label":"setAll","name":"SetAll","path":"../plugins/official/actions/logic/setAll","type":"ACTION","author":"Delaney Gillilan","slug":"Set all signals that match a regular expression","description":"","icon":"ion:checkmark-round","key":"static_library_source_plugins_official_actions_logic_set_all_ts","contents":"// Authors: Delaney Gillilan\n// Icon: ion:checkmark-round\n// Slug: Set all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const SetAll: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"setAll\",\n    method: (ctx, regexp, newValue) =\u003e {\n        const re = new RegExp(regexp);\n        ctx.walkSignals((name, signal) =\u003e\n            re.test(name) \u0026\u0026 (signal.value = newValue)\n        );\n    },\n};\n"},{"label":"toggleAll","name":"ToggleAll","path":"../plugins/official/actions/logic/toggleAll","type":"ACTION","author":"Delaney Gillilan","slug":"Toggle all signals that match a regular expression","description":"","icon":"material-symbols:toggle-off","key":"static_library_source_plugins_official_actions_logic_toggle_all_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:toggle-off\n// Slug: Toggle all signals that match a regular expression\n\nimport { ActionPlugin } from \"../../../../engine\";\n\nexport const ToggleAll: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"toggleAll\",\n    method: (ctx, regexp) =\u003e {\n        const re = new RegExp(regexp);\n        ctx.walkSignals((name, signal) =\u003e\n            re.test(name) \u0026\u0026 (signal.value = !signal.value)\n        );\n    },\n};\n"},{"label":"clampFit","name":"ClampFit","path":"../plugins/official/actions/math/clampFit","type":"ACTION","author":"Delaney Gillilan","slug":"Clamp a value to a new range","description":"This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.","icon":"material-symbols:fit-screen-outline","key":"static_library_source_plugins_official_actions_math_clamp_fit_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen-outline\n// Slug: Clamp a value to a new range\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const ClampFit: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clampFit\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) =\u003e {\n        return Math.max(\n            newMin,\n            Math.min(\n                newMax,\n                ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin,\n            ),\n        );\n    },\n};\n"},{"label":"clampFitInt","name":"ClampFitInt","path":"../plugins/official/actions/math/clampFitInt","type":"ACTION","author":"Delaney Gillilan","slug":"Clamp a value to a new range and round to the nearest integer","description":"This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range. The result is then rounded to the nearest integer.","icon":"material-symbols:fit-screen","key":"static_library_source_plugins_official_actions_math_clamp_fit_int_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-screen\n// Slug: Clamp a value to a new range and round to the nearest integer\n// Description: This action clamps a value to a new range. The value is first scaled to the new range, then clamped to the new range. This is useful for scaling a value to a new range, then clamping it to that range. The result is then rounded to the nearest integer.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const ClampFitInt: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"clampFitInt\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) =\u003e {\n        return Math.round(\n            Math.max(\n                newMin,\n                Math.min(\n                    newMax,\n                    ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) +\n                        newMin,\n                ),\n            ),\n        );\n    },\n};\n"},{"label":"fit","name":"Fit","path":"../plugins/official/actions/math/fit","type":"ACTION","author":"Delaney Gillilan","slug":"Linearly fit a value to a new range","description":"This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.","icon":"material-symbols-light:fit-width","key":"static_library_source_plugins_official_actions_math_fit_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols-light:fit-width\n// Slug: Linearly fit a value to a new range\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const Fit: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"fit\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) =\u003e {\n        return ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin;\n    },\n};\n"},{"label":"fitInt","name":"FitInt","path":"../plugins/official/actions/math/fitInt","type":"ACTION","author":"Delaney Gillilan","slug":"Linearly fit a value to a new range and round to the nearest integer","description":"This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.","icon":"material-symbols:fit-width","key":"static_library_source_plugins_official_actions_math_fit_int_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:fit-width\n// Slug: Linearly fit a value to a new range and round to the nearest integer\n// Description: This action linearly fits a value to a new range. The value is first scaled to the new range.  Note it is not clamped to the new range.\n\nimport { ActionPlugin, AttributeContext } from \"../../../../engine\";\n\nexport const FitInt: ActionPlugin = {\n    pluginType: \"action\",\n    name: \"fitInt\",\n    method: (\n        _: AttributeContext,\n        v: number,\n        oldMin: number,\n        oldMax: number,\n        newMin: number,\n        newMax: number,\n    ) =\u003e {\n        return Math.round(\n            ((v - oldMin) / (oldMax - oldMin)) * (newMax - newMin) + newMin,\n        );\n    },\n};\n"},{"label":"Indicator","name":"Indicator","path":"../plugins/official/attributes/backend/indicator","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Sets the indicator signal used when fetching data via SSE","description":"must be a valid signal name","icon":"material-symbols:network-wifi","key":"static_library_source_plugins_official_attributes_backend_indicator_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:network-wifi\n// Slug: Sets the indicator signal used when fetching data via SSE\n// Description: must be a valid signal name\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { DATASTAR } from \"../../../../engine/consts\";\nimport { ERR_NOT_FOUND } from \"../../../../engine/errors\";\nimport { isDatastarGeneratedID } from \"../../../../utils/regex\";\nimport {\n    DATASTAR_SSE_EVENT,\n    DatastarSSEEvent,\n    FINISHED,\n    STARTED,\n} from \"../../watchers/backend/sseShared\";\n\nexport const INDICATOR_CLASS = `${DATASTAR}-indicator`;\nexport const INDICATOR_LOADING_CLASS = `${INDICATOR_CLASS}-loading`;\n\nexport const Indicator: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"indicator\",\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) =\u003e {\n        const { expression, upsertSignal, el } = ctx;\n        if (isDatastarGeneratedID(el)) {\n            // Indicator cannot be used on an element without an ID\n            // otherwise it will auto generate and most like will be incorrect\n            // if you get to the point match sure this element has a unique ID.\n            throw ERR_NOT_FOUND;\n        }\n        const signalName = expression;\n        const signal = upsertSignal(signalName, false);\n\n        const watcher = (event: CustomEvent\u003cDatastarSSEEvent\u003e) =\u003e {\n            const { type, argsRaw: { elID } } = event.detail;\n            if (elID !== el.id) return;\n            switch (type) {\n                case STARTED:\n                    signal.value = true;\n                    break;\n                case FINISHED:\n                    signal.value = false;\n                    break;\n            }\n        };\n\n        document.addEventListener(DATASTAR_SSE_EVENT, watcher);\n\n        return () =\u003e {\n            document.removeEventListener(DATASTAR_SSE_EVENT, watcher);\n        };\n    },\n};\n"},{"label":"Bind","name":"Bind","path":"../plugins/official/attributes/dom/bind","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Bind attributes to expressions","description":"Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.","icon":"akar-icons:link-chain","key":"static_library_source_plugins_official_attributes_dom_bind_ts","contents":"// Authors: Delaney Gillilan\n// Icon: akar-icons:link-chain\n// Slug: Bind attributes to expressions\n// Description: Any attribute can be bound to an expression. The attribute will be updated reactively whenever the expression signal changes.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { kebabize } from \"../../../../utils/text\";\n\nexport const Bind: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"bind\",\n    mustNotEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) =\u003e {\n        return ctx.reactivity.effect(async () =\u003e {\n            const key = kebabize(ctx.key);\n            const value = ctx.expressionFn(ctx);\n            let v: string;\n            if (typeof value === \"string\") {\n                v = value;\n            } else {\n                v = JSON.stringify(value);\n            }\n            if (!v || v === \"false\" || v === \"null\" || v === \"undefined\") {\n                ctx.el.removeAttribute(key);\n            } else {\n                ctx.el.setAttribute(key, v);\n            }\n        });\n    },\n};\n"},{"label":"Class","name":"Class","path":"../plugins/official/attributes/dom/class","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Add or remove classes from an element reactively","description":"This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.","icon":"ic:baseline-format-paint","key":"static_library_source_plugins_official_attributes_dom_class_ts","contents":"// Authors: Delaney Gillilan\n// Icon: ic:baseline-format-paint\n// Slug: Add or remove classes from an element reactively\n// Description: This action adds or removes classes from an element reactively based on the expression provided. The expression should be an object where the keys are the class names and the values are booleans. If the value is true, the class is added. If the value is false, the class is removed.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Class: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"class\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) =\u003e {\n        return ctx.reactivity.effect(() =\u003e {\n            const classes: Object = ctx.expressionFn(ctx);\n            for (const [k, v] of Object.entries(classes)) {\n                const classNames = k.split(\" \");\n                if (v) {\n                    ctx.el.classList.add(...classNames);\n                } else {\n                    ctx.el.classList.remove(...classNames);\n                }\n            }\n        });\n    },\n};\n"},{"label":"Model","name":"Model","path":"../plugins/official/attributes/dom/model","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Enable two-way data binding","description":"This attribute plugin enables two-way data binding for input elements.","icon":"clarity:two-way-arrows-line","key":"static_library_source_plugins_official_attributes_dom_model_ts","contents":"// Authors: Delaney Gillilan\n// Icon: clarity:two-way-arrows-line\n// Slug: Enable two-way data binding\n// Description: This attribute plugin enables two-way data binding for input elements.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport {\n    ERR_BAD_ARGS,\n    ERR_METHOD_NOT_ALLOWED,\n} from \"../../../../engine/errors\";\n\nconst dataURIRegex = /^data:(?\u003cmime\u003e[^;]+);base64,(?\u003ccontents\u003e.*)$/;\nconst updateModelEvents = [\"change\", \"input\", \"keydown\"];\n\nexport const Model: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"model\",\n    mustHaveEmptyKey: true,\n    // bypassExpressionFunctionCreation: () =\u003e true,\n    onLoad: (ctx) =\u003e {\n        const { el, expression, upsertSignal } = ctx;\n        const signalName = expression;\n        if (typeof signalName !== \"string\") {\n            // Signal name must be a string\n            throw ERR_BAD_ARGS;\n        }\n\n        const tnl = el.tagName.toLowerCase();\n\n        let signalDefault: string | boolean | File = \"\";\n        const isInput = tnl.includes(\"input\");\n        const type = el.getAttribute(\"type\");\n        const isCheckbox = tnl.includes(\"checkbox\") ||\n            (isInput \u0026\u0026 type === \"checkbox\");\n        if (isCheckbox) {\n            signalDefault = false;\n        }\n        const isSelect = tnl.includes(\"select\");\n        const isRadio = tnl.includes(\"radio\") || (isInput \u0026\u0026 type === \"radio\");\n        const isFile = isInput \u0026\u0026 type === \"file\";\n        if (isFile) {\n            // can't set a default value for a file input, yet\n        }\n        if (isRadio) {\n            const name = el.getAttribute(\"name\");\n            if (!name?.length) {\n                el.setAttribute(\"name\", signalName);\n            }\n        }\n\n        const signal = upsertSignal(signalName, signalDefault);\n\n        const setInputFromSignal = () =\u003e {\n            const hasValue = \"value\" in el;\n            const v = signal.value;\n            const vStr = `${v}`;\n            if (isCheckbox || isRadio) {\n                const input = el as HTMLInputElement;\n                if (isCheckbox) {\n                    input.checked = v;\n                } else if (isRadio) {\n                    // evaluate the value as string to handle any type casting\n                    // automatically since the attribute has to be a string anyways\n                    input.checked = vStr === input.value;\n                }\n            } else if (isFile) {\n                // File input reading from a signal is not supported yet\n            } else if (isSelect) {\n                const select = el as HTMLSelectElement;\n                if (select.multiple) {\n                    Array.from(select.options).forEach((opt) =\u003e {\n                        if (opt?.disabled) return;\n                        opt.selected = v.includes(opt.value);\n                    });\n                } else {\n                    select.value = vStr;\n                }\n            } else if (hasValue) {\n                el.value = vStr;\n            } else {\n                el.setAttribute(\"value\", vStr);\n            }\n        };\n        const cleanupSetInputFromSignal = ctx.reactivity.effect(\n            setInputFromSignal,\n        );\n\n        const setSignalFromInput = async () =\u003e {\n            if (isFile) {\n                const files = [...((el as HTMLInputElement)?.files || [])],\n                    allContents: string[] = [],\n                    allMimes: string[] = [],\n                    allNames: string[] = [];\n\n                await Promise.all(\n                    files.map((f) =\u003e {\n                        return new Promise\u003cvoid\u003e((resolve) =\u003e {\n                            const reader = new FileReader();\n                            reader.onload = () =\u003e {\n                                if (typeof reader.result !== \"string\") {\n                                    // console.error(`Invalid result type: ${typeof reader.result}`);\n                                    throw ERR_BAD_ARGS;\n                                }\n                                const match = reader.result.match(dataURIRegex);\n                                if (!match?.groups) {\n                                    // console.error(`Invalid data URI: ${reader.result}`);\n                                    throw ERR_BAD_ARGS;\n                                }\n                                allContents.push(match.groups.contents);\n                                allMimes.push(match.groups.mime);\n                                allNames.push(f.name);\n                            };\n                            reader.onloadend = () =\u003e resolve(void 0);\n                            reader.readAsDataURL(f);\n                        });\n                    }),\n                );\n\n                signal.value = allContents;\n                const s = ctx.store();\n                const mimeName = `${signalName}Mimes`,\n                    nameName = `${signalName}Names`;\n                if (mimeName in s) {\n                    s[`${mimeName}`].value = allMimes;\n                }\n                if (nameName in s) {\n                    s[`${nameName}`].value = allNames;\n                }\n                return;\n            }\n\n            const current = signal.value;\n            const input = (el as HTMLInputElement) || (el as HTMLElement);\n\n            if (typeof current === \"number\") {\n                signal.value = Number(\n                    input.value || input.getAttribute(\"value\"),\n                );\n            } else if (typeof current === \"string\") {\n                signal.value = input.value || input.getAttribute(\"value\") ||\n                    \"\";\n            } else if (typeof current === \"boolean\") {\n                if (isCheckbox) {\n                    signal.value = input.checked ||\n                        input.getAttribute(\"checked\") === \"true\";\n                } else {\n                    signal.value = Boolean(\n                        input.value || input.getAttribute(\"value\"),\n                    );\n                }\n            } else if (typeof current === \"undefined\") {\n            } else if (typeof current === \"bigint\") {\n                signal.value = BigInt(\n                    input.value || input.getAttribute(\"value\") || \"0\",\n                );\n            } else if (Array.isArray(current)) {\n                // check if the input is a select element\n                if (isSelect) {\n                    const select = el as HTMLSelectElement;\n                    const selectedOptions = [...select.selectedOptions];\n                    const selectedValues = selectedOptions.map((opt) =\u003e\n                        opt.value\n                    );\n                    signal.value = selectedValues;\n                } else {\n                    signal.value = JSON.parse(input.value).split(\",\");\n                }\n                console.log(input.value);\n            } else {\n                // console.log(`Unsupported type ${typeof current}`);\n                throw ERR_METHOD_NOT_ALLOWED;\n            }\n        };\n\n        const parts = el.tagName.split(\"-\");\n        const isCustomElement = parts.length \u003e 1;\n        if (isCustomElement) {\n            const customElementPrefix = parts[0].toLowerCase();\n            updateModelEvents.forEach((eventType) =\u003e {\n                updateModelEvents.push(`${customElementPrefix}-${eventType}`);\n            });\n        }\n\n        updateModelEvents.forEach((eventType) =\u003e\n            el.addEventListener(eventType, setSignalFromInput)\n        );\n\n        return () =\u003e {\n            cleanupSetInputFromSignal();\n            updateModelEvents.forEach((event) =\u003e\n                el.removeEventListener(event, setSignalFromInput)\n            );\n        };\n    },\n};\n"},{"label":"On","name":"On","path":"../plugins/official/attributes/dom/on","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Add an event listener to an element","description":"This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.","icon":"material-symbols:mail","key":"static_library_source_plugins_official_attributes_dom_on_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:mail\n// Slug: Add an event listener to an element\n// Description: This action adds an event listener to an element. The event listener can be triggered by a variety of events, such as clicks, keypresses, and more. The event listener can also be set to trigger only once, or to be passive or capture. The event listener can also be debounced or throttled. The event listener can also be set to trigger only when the event target is outside the element.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { argsHas, argsToMs } from \"../../../../utils/arguments\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport { kebabize } from \"../../../../utils/text\";\nimport { debounce, throttle } from \"../../../../utils/timing\";\n\nconst knownOnModifiers = new Set([\n    \"window\",\n    \"once\",\n    \"passive\",\n    \"capture\",\n    \"debounce\",\n    \"throttle\",\n    \"remote\",\n    \"outside\",\n]);\n\nlet lastStoreMarshalled = \"\";\n\n// Sets the event listener of the element\nexport const On: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"on\",\n    mustNotEmptyKey: true,\n    mustNotEmptyExpression: true,\n    argumentNames: [\"evt\"],\n    onLoad: (ctx) =\u003e {\n        const { el, key, expressionFn } = ctx;\n\n        let target: Element | Window | Document = ctx.el;\n        if (ctx.modifiers.get(\"window\")) {\n            target = window;\n        }\n\n        let callback = (evt?: Event) =\u003e {\n            expressionFn(ctx, evt);\n        };\n\n        const debounceArgs = ctx.modifiers.get(\"debounce\");\n        if (debounceArgs) {\n            const wait = argsToMs(debounceArgs);\n            const leading = argsHas(debounceArgs, \"leading\", false);\n            const trailing = argsHas(debounceArgs, \"noTrail\", true);\n            callback = debounce(callback, wait, leading, trailing);\n        }\n\n        const throttleArgs = ctx.modifiers.get(\"throttle\");\n        if (throttleArgs) {\n            const wait = argsToMs(throttleArgs);\n            const leading = argsHas(throttleArgs, \"noLead\", true);\n            const trailing = argsHas(throttleArgs, \"noTrail\", false);\n            callback = throttle(callback, wait, leading, trailing);\n        }\n\n        const evtListOpts: AddEventListenerOptions = {\n            capture: true,\n            passive: false,\n            once: false,\n        };\n        if (!ctx.modifiers.has(\"capture\")) evtListOpts.capture = false;\n        if (ctx.modifiers.has(\"passive\")) evtListOpts.passive = true;\n        if (ctx.modifiers.has(\"once\")) evtListOpts.once = true;\n\n        const unknownModifierKeys = [...ctx.modifiers.keys()].filter((key) =\u003e\n            !knownOnModifiers.has(key)\n        );\n\n        unknownModifierKeys.forEach((attrName) =\u003e {\n            const eventValues = ctx.modifiers.get(attrName) || [];\n            const cb = callback;\n            const revisedCallback = () =\u003e {\n                const evt = event as any;\n                const attr = evt[attrName];\n                let valid: boolean;\n\n                if (typeof attr === \"function\") {\n                    valid = attr(...eventValues);\n                } else if (typeof attr === \"boolean\") {\n                    valid = attr;\n                } else if (typeof attr === \"string\") {\n                    const lowerAttr = attr.toLowerCase().trim();\n                    const expr = eventValues.join(\"\").toLowerCase().trim();\n                    valid = lowerAttr === expr;\n                } else {\n                    // console.error(`Invalid value for ${attrName} modifier on ${key} on ${el}`);\n                    throw ERR_BAD_ARGS;\n                }\n\n                if (valid) {\n                    cb(evt);\n                }\n            };\n            callback = revisedCallback;\n        });\n\n        const eventName = kebabize(key).toLowerCase();\n        switch (eventName) {\n            case \"load\":\n                callback();\n                delete ctx.el.dataset.onLoad;\n                return () =\u003e {};\n\n            case \"raf\":\n                let rafId: number | undefined;\n                const raf = () =\u003e {\n                    callback();\n                    rafId = requestAnimationFrame(raf);\n                };\n                rafId = requestAnimationFrame(raf);\n\n                return () =\u003e {\n                    if (rafId) cancelAnimationFrame(rafId);\n                };\n\n            case \"store-change\":\n                return ctx.reactivity.effect(() =\u003e {\n                    const store = ctx.store();\n                    let storeValue = store.value;\n                    if (ctx.modifiers.has(\"remote\")) {\n                        storeValue = remoteSignals(storeValue);\n                    }\n                    const current = JSON.stringify(storeValue);\n                    if (lastStoreMarshalled !== current) {\n                        lastStoreMarshalled = current;\n                        callback();\n                    }\n                });\n\n            default:\n                const testOutside = ctx.modifiers.has(\"outside\");\n                if (testOutside) {\n                    target = document;\n                    const cb = callback;\n                    let called = false;\n                    const targetOutsideCallback = (e?: Event) =\u003e {\n                        const targetHTML = e?.target as HTMLElement;\n                        if (!targetHTML) return;\n                        const isEl = el.id === targetHTML.id;\n                        if (isEl \u0026\u0026 called) {\n                            called = false;\n                        }\n                        if (!isEl \u0026\u0026 !called) {\n                            cb(e);\n                            called = true;\n                        }\n                    };\n                    callback = targetOutsideCallback;\n                }\n\n                target.addEventListener(eventName, callback, evtListOpts);\n                return () =\u003e {\n                    // console.log(`Removing event listener for ${eventName} on ${el}`)\n                    target.removeEventListener(eventName, callback);\n                };\n        }\n    },\n};\n"},{"label":"Ref","name":"Ref","path":"../plugins/official/attributes/dom/ref","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Create a reference to an element","description":"This attribute creates a reference to an element that can be used in other expressions.","icon":"mdi:cursor-pointer","key":"static_library_source_plugins_official_attributes_dom_ref_ts","contents":"// Authors: Delaney Gillilan\n// Icon: mdi:cursor-pointer\n// Slug: Create a reference to an element\n// Description: This attribute creates a reference to an element that can be used in other expressions.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\n// Sets the value of the element\nexport const Ref: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"ref\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n    bypassExpressionFunctionCreation: () =\u003e true,\n    onLoad: (ctx) =\u003e {\n        const signalName = ctx.expression;\n        ctx.upsertSignal(signalName, ctx.el);\n\n        return () =\u003e {\n            ctx.removeSignals(signalName);\n        };\n    },\n};\n"},{"label":"Text","name":"Text","path":"../plugins/official/attributes/dom/text","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Set the text content of an element","description":"This attribute sets the text content of an element to the result of the expression.","icon":"tabler:typography","key":"static_library_source_plugins_official_attributes_dom_text_ts","contents":"// Authors: Delaney Gillilan\n// Icon: tabler:typography\n// Slug: Set the text content of an element\n// Description: This attribute sets the text content of an element to the result of the expression.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\n\nexport const Text: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"text\",\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) =\u003e {\n        const { el, expressionFn } = ctx;\n        if (!(el instanceof HTMLElement)) {\n            // Element is not HTMLElement\n            throw ERR_BAD_ARGS;\n        }\n        return ctx.reactivity.effect(() =\u003e {\n            const res = expressionFn(ctx);\n            el.textContent = `${res}`;\n        });\n    },\n};\n"},{"label":"Persist","name":"Persist","path":"../plugins/official/attributes/storage/persist","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Persist data to local storage or session storage","description":"This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.","icon":"mdi:floppy-variant","key":"static_library_source_plugins_official_attributes_storage_persist_ts","contents":"// Authors: Delaney Gillilan\n// Icon: mdi:floppy-variant\n// Slug: Persist data to local storage or session storage\n// Description: This plugin allows you to persist data to local storage or session storage.  Once you add this attribute the data will be persisted to local storage or session storage.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { DATASTAR, DATASTAR_EVENT } from \"../../../../engine/consts\";\nimport { remoteSignals } from \"../../../../utils/signals\";\nimport { DatastarSSEEvent } from \"../../watchers/backend/sseShared\";\n\nexport const Persist: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"persist\",\n    allowedModifiers: new Set([\"local\", \"session\", \"remote\"]),\n    onLoad: (ctx) =\u003e {\n        const key = ctx.key || DATASTAR;\n        const expression = ctx.expression;\n        const keys = new Set\u003cstring\u003e();\n\n        if (expression.trim() !== \"\") {\n            const value = ctx.expressionFn(ctx);\n            const parts = value.split(\" \");\n            for (const part of parts) {\n                keys.add(part);\n            }\n        }\n\n        let lastMarshalled = \"\";\n        const storageType = ctx.modifiers.has(\"session\") ? \"session\" : \"local\";\n        const useRemote = ctx.modifiers.has(\"remote\");\n\n        const storeUpdateHandler = ((_: CustomEvent\u003cDatastarSSEEvent\u003e) =\u003e {\n            let store = ctx.store();\n            if (useRemote) {\n                store = remoteSignals(store);\n            }\n            if (keys.size \u003e 0) {\n                const newStore: Record\u003cstring, any\u003e = {};\n                for (const key of keys) {\n                    const parts = key.split(\".\");\n                    let newSubstore = newStore;\n                    let subStore = store;\n                    for (let i = 0; i \u003c parts.length - 1; i++) {\n                        const part = parts[i];\n                        if (!newSubstore[part]) {\n                            newSubstore[part] = {};\n                        }\n                        newSubstore = newSubstore[part];\n                        subStore = subStore[part];\n                    }\n\n                    const lastPart = parts[parts.length - 1];\n                    newSubstore[lastPart] = subStore[lastPart];\n                }\n                store = newStore;\n            }\n\n            const marshalledStore = JSON.stringify(store);\n\n            if (marshalledStore === lastMarshalled) {\n                return;\n            }\n\n            if (storageType === \"session\") {\n                window.sessionStorage.setItem(key, marshalledStore);\n            } else {\n                window.localStorage.setItem(key, marshalledStore);\n            }\n\n            lastMarshalled = marshalledStore;\n        }) as EventListener;\n\n        window.addEventListener(DATASTAR_EVENT, storeUpdateHandler);\n\n        let marshalledStore: string | null;\n\n        if (storageType === \"session\") {\n            marshalledStore = window.sessionStorage.getItem(key);\n        } else {\n            marshalledStore = window.localStorage.getItem(key);\n        }\n\n        if (!!marshalledStore) {\n            const store = JSON.parse(marshalledStore);\n            for (const key in store) {\n                ctx.upsertSignal(key, store[key]);\n            }\n        }\n\n        return () =\u003e {\n            window.removeEventListener(DATASTAR_EVENT, storeUpdateHandler);\n        };\n    },\n};\n"},{"label":"ReplaceUrl","name":"ReplaceUrl","path":"../plugins/official/attributes/url/replaceUrl","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Replace the current URL with a new URL","description":"This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.","icon":"carbon:url","key":"static_library_source_plugins_official_attributes_url_replace_url_ts","contents":"// Authors: Delaney Gillilan\n// Icon: carbon:url\n// Slug: Replace the current URL with a new URL\n// Description: This plugin allows you to replace the current URL with a new URL.  Once you add this attribute the current URL will be replaced with the new URL.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const ReplaceUrl: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"replaceUrl\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) =\u003e {\n        return ctx.reactivity.effect(() =\u003e {\n            const value = ctx.expressionFn(ctx);\n            const baseUrl = window.location.href;\n            const url = new URL(value, baseUrl).toString();\n\n            window.history.replaceState({}, \"\", url);\n        });\n    },\n};\n"},{"label":"Intersection","name":"Intersection","path":"../plugins/official/attributes/visibility/intersects","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Run expression when element intersects with viewport","description":"An attribute that runs an expression when the element intersects with the viewport.","icon":"mdi-light:vector-intersection","key":"static_library_source_plugins_official_attributes_visibility_intersects_ts","contents":"// Authors: Delaney Gillilan\n// Icon: mdi-light:vector-intersection\n// Slug: Run expression when element intersects with viewport\n// Description: An attribute that runs an expression when the element intersects with the viewport.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nconst ONCE = \"once\";\nconst HALF = \"half\";\nconst FULL = \"full\";\n\n// Run expression when element intersects with viewport\nexport const Intersection: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"intersects\",\n    allowedModifiers: new Set([ONCE, HALF, FULL]),\n    mustHaveEmptyKey: true,\n    onLoad: (ctx) =\u003e {\n        const { modifiers } = ctx;\n        const options = { threshold: 0 };\n        if (modifiers.has(FULL)) options.threshold = 1;\n        else if (modifiers.has(HALF)) options.threshold = 0.5;\n\n        const observer = new IntersectionObserver((entries) =\u003e {\n            entries.forEach((entry) =\u003e {\n                if (entry.isIntersecting) {\n                    ctx.expressionFn(ctx);\n                    if (modifiers.has(ONCE)) {\n                        observer.disconnect();\n                        delete ctx.el.dataset[ctx.rawKey];\n                    }\n                }\n            });\n        }, options);\n\n        observer.observe(ctx.el);\n        return () =\u003e observer.disconnect();\n    },\n};\n"},{"label":"ScrollIntoView","name":"ScrollIntoView","path":"../plugins/official/attributes/visibility/scrollIntoView","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Scroll an element into view","description":"This attribute scrolls the element into view.","icon":"hugeicons:mouse-scroll-01","key":"static_library_source_plugins_official_attributes_visibility_scroll_into_view_ts","contents":"// Authors: Delaney Gillilan\n// Icon: hugeicons:mouse-scroll-01\n// Slug: Scroll an element into view\n// Description: This attribute scrolls the element into view.\n\nimport { AttributeContext, AttributePlugin } from \"../../../../engine\";\nimport { scrollIntoView } from \"../../../../utils/dom\";\n\nconst SMOOTH = \"smooth\";\nconst INSTANT = \"instant\";\nconst AUTO = \"auto\";\nconst HSTART = \"hstart\";\nconst HCENTER = \"hcenter\";\nconst HEND = \"hend\";\nconst HNEAREST = \"hnearest\";\nconst VSTART = \"vstart\";\nconst VCENTER = \"vcenter\";\nconst VEND = \"vend\";\nconst VNEAREST = \"vnearest\";\nconst FOCUS = \"focus\";\n\nconst CENTER = \"center\";\nconst START = \"start\";\nconst END = \"end\";\nconst NEAREST = \"nearest\";\n\n// Scrolls the element into view\nexport const ScrollIntoView: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"scrollIntoView\",\n    mustHaveEmptyKey: true,\n    mustHaveEmptyExpression: true,\n    allowedModifiers: new Set([\n        SMOOTH,\n        INSTANT,\n        AUTO,\n        HSTART,\n        HCENTER,\n        HEND,\n        HNEAREST,\n        VSTART,\n        VCENTER,\n        VEND,\n        VNEAREST,\n        FOCUS,\n    ]),\n\n    onLoad: ({ el, modifiers, rawKey }: AttributeContext) =\u003e {\n        if (!el.tabIndex) el.setAttribute(\"tabindex\", \"0\");\n        const opts: ScrollIntoViewOptions = {\n            behavior: SMOOTH,\n            block: CENTER,\n            inline: CENTER,\n        };\n        if (modifiers.has(SMOOTH)) opts.behavior = SMOOTH;\n        if (modifiers.has(INSTANT)) opts.behavior = INSTANT;\n        if (modifiers.has(AUTO)) opts.behavior = AUTO;\n        if (modifiers.has(HSTART)) opts.inline = START;\n        if (modifiers.has(HCENTER)) opts.inline = CENTER;\n        if (modifiers.has(HEND)) opts.inline = END;\n        if (modifiers.has(HNEAREST)) opts.inline = NEAREST;\n        if (modifiers.has(VSTART)) opts.block = START;\n        if (modifiers.has(VCENTER)) opts.block = CENTER;\n        if (modifiers.has(VEND)) opts.block = END;\n        if (modifiers.has(VNEAREST)) opts.block = NEAREST;\n\n        scrollIntoView(el, opts, modifiers.has(\"focus\"));\n        delete el.dataset[rawKey];\n        return () =\u003e {};\n    },\n};\n"},{"label":"Show","name":"Show","path":"../plugins/official/attributes/visibility/show","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Show or hide an element","description":"This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.","icon":"streamline:interface-edit-view-eye-eyeball-open-view","key":"static_library_source_plugins_official_attributes_visibility_show_ts","contents":"// Authors: Delaney Gillilan\n// Icon: streamline:interface-edit-view-eye-eyeball-open-view\n// Slug: Show or hide an element\n// Description: This attribute shows or hides an element based on the value of the expression. If the expression is true, the element is shown. If the expression is false, the element is hidden. The element is hidden by setting the display property to none.\n\nimport { AttributePlugin } from \"../../../../engine\";\n\nexport const Show: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: \"show\",\n    mustHaveEmptyKey: true,\n    mustNotEmptyExpression: true,\n\n    onLoad: (ctx) =\u003e {\n        return ctx.reactivity.effect(async () =\u003e {\n            const shouldShow: boolean = ctx.expressionFn(ctx);\n\n            if (shouldShow) {\n                if (ctx.el.style.display === \"none\") {\n                    ctx.el.style.removeProperty(\"display\");\n                }\n            } else {\n                ctx.el.style.setProperty(\"display\", \"none\");\n            }\n        });\n    },\n};\n"},{"label":"ViewTransition","name":"ViewTransition","path":"../plugins/official/attributes/visibility/viewTransition","type":"ATTRIBUTE","author":"Delaney Gillilan","slug":"Setup view transitions","description":"This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.","icon":"material-symbols:masked-transitions","key":"static_library_source_plugins_official_attributes_visibility_view_transition_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:masked-transitions\n// Slug: Setup view transitions\n// Description: This attribute plugin sets up view transitions for the current view. This plugin requires the view transition API to be enabled in the browser. If the browser does not support view transitions, an error will be logged to the console.\n\nimport { AttributePlugin } from \"../../../../engine\";\nimport { supportsViewTransitions } from \"../../../../utils/view-transitions\";\n\nconst VIEW_TRANSITION = \"view-transition\";\n\nexport const ViewTransition: AttributePlugin = {\n    pluginType: \"attribute\",\n    name: VIEW_TRANSITION,\n    onGlobalInit() {\n        let hasViewTransitionMeta = false;\n        document.head.childNodes.forEach((node) =\u003e {\n            if (\n                node instanceof HTMLMetaElement \u0026\u0026\n                node.name === VIEW_TRANSITION\n            ) {\n                hasViewTransitionMeta = true;\n            }\n        });\n\n        if (!hasViewTransitionMeta) {\n            const meta = document.createElement(\"meta\");\n            meta.name = VIEW_TRANSITION;\n            meta.content = \"same-origin\";\n            document.head.appendChild(meta);\n        }\n    },\n    onLoad: (ctx) =\u003e {\n        if (!supportsViewTransitions) {\n            console.error(\"Browser does not support view transitions\");\n            return;\n        }\n\n        return ctx.reactivity.effect(() =\u003e {\n            const { el, expressionFn } = ctx;\n            let name = expressionFn(ctx);\n            if (!name) return;\n\n            const elVTASTyle = el.style as unknown as CSSStyleDeclaration;\n            elVTASTyle.viewTransitionName = name;\n        });\n    },\n};\n"},{"label":"ExecuteScript","name":"ExecuteScript","path":"../plugins/official/watchers/backend/sseExecuteScript","type":"WATCHER","author":"Delaney Gillilan","slug":"Execute JavaScript from a Server-Sent Event","description":"Execute JavaScript from a Server-Sent Event","icon":"tabler:file-type-js","key":"static_library_source_plugins_official_watchers_backend_sse_execute_script_ts","contents":"// Authors: Delaney Gillilan\n// Icon: tabler:file-type-js\n// Slug: Execute JavaScript from a Server-Sent Event\n// Description: Execute JavaScript from a Server-Sent Event\n\nimport { WatcherPlugin } from \"../../../../engine/types\";\n\nimport {\n    DefaultExecuteScriptAttributes,\n    DefaultExecuteScriptAutoRemove,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const ExecuteScript: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.ExecuteScript,\n    onGlobalInit: async () =\u003e {\n        datastarSSEEventWatcher(\n            EventTypes.ExecuteScript,\n            (\n                {\n                    autoRemove: autoRemoveRaw =\n                        `${DefaultExecuteScriptAutoRemove}`,\n                    attributes: attributesRaw = DefaultExecuteScriptAttributes,\n                    script,\n                },\n            ) =\u003e {\n                const autoRemove = isBoolString(autoRemoveRaw);\n                if (!script?.length) {\n                    // No script provided\n                    throw ERR_BAD_ARGS;\n                }\n                const scriptEl = document.createElement(\"script\");\n                attributesRaw.split(\"\\n\").forEach((attr) =\u003e {\n                    const pivot = attr.indexOf(\" \");\n                    const key = attr.slice(0, pivot).trim();\n                    const value = attr.slice(pivot).trim();\n                    scriptEl.setAttribute(key, value);\n                });\n                scriptEl.text = script;\n                document.head.appendChild(scriptEl);\n                if (autoRemove) {\n                    scriptEl.remove();\n                }\n            },\n        );\n    },\n};\n"},{"label":"MergeFragments","name":"MergeFragments","path":"../plugins/official/watchers/backend/sseMergeFragment","type":"WATCHER","author":"Delaney Gillilan","slug":"Use Server-Sent Events to fetch data from a server using the Datastar SDK interface","description":"Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.","icon":"material-symbols:cloud-download","key":"static_library_source_plugins_official_watchers_backend_sse_merge_fragment_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:cloud-download\n// Slug: Use Server-Sent Events to fetch data from a server using the Datastar SDK interface\n// Description: Remember, SSE is just a regular SSE request but with the ability to send 0-inf messages to the client.\n\nimport { InitContext, WatcherPlugin } from \"../../../../engine\";\nimport {\n    DefaultFragmentMergeMode,\n    DefaultFragmentsUseViewTransitions,\n    DefaultSettleDurationMs,\n    EventTypes,\n    FragmentMergeModes,\n} from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { idiomorph } from \"../../../../vendored/idiomorph\";\nimport {\n    datastarSSEEventWatcher,\n    SETTLING_CLASS,\n    SWAPPING_CLASS,\n} from \"./sseShared\";\n\nexport const MergeFragments: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.MergeFragments,\n    onGlobalInit: async (ctx) =\u003e {\n        const fragmentContainer = document.createElement(\"template\");\n        datastarSSEEventWatcher(EventTypes.MergeFragments, ({\n            fragments: fragmentsRaw = \"\u003cdiv\u003e\u003c/div\u003e\",\n            selector = \"\",\n            mergeMode = DefaultFragmentMergeMode,\n            settleDuration: settleDurationRaw = `${DefaultSettleDurationMs}`,\n            useViewTransition: useViewTransitionRaw =\n                `${DefaultFragmentsUseViewTransitions}`,\n        }) =\u003e {\n            const settleDuration = parseInt(settleDurationRaw);\n            const useViewTransition = isBoolString(useViewTransitionRaw);\n\n            fragmentContainer.innerHTML = fragmentsRaw.trim();\n            const fragments = [...fragmentContainer.content.children];\n            fragments.forEach((fragment) =\u003e {\n                if (!(fragment instanceof Element)) {\n                    // No fragments found\n                    throw ERR_BAD_ARGS;\n                }\n\n                const selectorOrID = selector ||\n                    `#${fragment.getAttribute(\"id\")}`;\n                const targets = document.querySelectorAll(selectorOrID) ||\n                    [];\n                const allTargets = [...targets];\n                if (!allTargets.length) {\n                    // No targets found\n                    throw ERR_BAD_ARGS;\n                }\n\n                if (supportsViewTransitions \u0026\u0026 useViewTransition) {\n                    docWithViewTransitionAPI.startViewTransition(() =\u003e\n                        applyToTargets(\n                            ctx,\n                            mergeMode,\n                            settleDuration,\n                            fragment,\n                            allTargets,\n                        )\n                    );\n                } else {\n                    applyToTargets(\n                        ctx,\n                        mergeMode,\n                        settleDuration,\n                        fragment,\n                        allTargets,\n                    );\n                }\n            });\n        });\n    },\n};\n\nfunction applyToTargets(\n    ctx: InitContext,\n    mergeMode: string,\n    settleDuration: number,\n    fragment: Element,\n    capturedTargets: Element[],\n) {\n    for (const initialTarget of capturedTargets) {\n        initialTarget.classList.add(SWAPPING_CLASS);\n        const originalHTML = initialTarget.outerHTML;\n        let modifiedTarget = initialTarget;\n        switch (mergeMode) {\n            case FragmentMergeModes.Morph:\n                const result = idiomorph(\n                    modifiedTarget,\n                    fragment,\n                    {\n                        callbacks: {\n                            beforeNodeRemoved: (\n                                oldNode: Element,\n                                _: Element,\n                            ) =\u003e {\n                                ctx.cleanup(\n                                    oldNode,\n                                );\n                                return true;\n                            },\n                        },\n                    },\n                );\n                if (!result?.length) {\n                    // No morph result\n                    throw ERR_BAD_ARGS;\n                }\n                modifiedTarget = result[0] as Element;\n                break;\n            case FragmentMergeModes.Inner:\n                // Replace the contents of the target element with the response\n                modifiedTarget.innerHTML = fragment.innerHTML;\n                break;\n            case FragmentMergeModes.Outer:\n                // Replace the entire target element with the response\n                modifiedTarget.replaceWith(fragment);\n                break;\n            case FragmentMergeModes.Prepend:\n                // Insert the response before the first child of the target element\n                modifiedTarget.prepend(fragment);\n                break;\n            case FragmentMergeModes.Append:\n                // Insert the response after the last child of the target element\n                modifiedTarget.append(fragment);\n                break;\n            case FragmentMergeModes.Before:\n                // Insert the response before the target element\n                modifiedTarget.before(fragment);\n                break;\n            case FragmentMergeModes.After:\n                // Insert the response after the target element\n                modifiedTarget.after(fragment);\n                break;\n            case FragmentMergeModes.UpsertAttributes:\n                // Upsert the attributes of the target element\n                fragment.getAttributeNames().forEach(\n                    (attrName) =\u003e {\n                        const value = fragment.getAttribute(\n                            attrName,\n                        )!;\n                        modifiedTarget.setAttribute(\n                            attrName,\n                            value,\n                        );\n                    },\n                );\n                break;\n            default:\n                // Unknown merge type\n                throw ERR_BAD_ARGS;\n        }\n        ctx.cleanup(modifiedTarget);\n        modifiedTarget.classList.add(SWAPPING_CLASS);\n\n        ctx.applyPlugins(document.body);\n\n        setTimeout(() =\u003e {\n            initialTarget.classList.remove(SWAPPING_CLASS);\n            modifiedTarget.classList.remove(SWAPPING_CLASS);\n        }, settleDuration);\n\n        const revisedHTML = modifiedTarget.outerHTML;\n\n        if (originalHTML !== revisedHTML) {\n            modifiedTarget.classList.add(SETTLING_CLASS);\n            setTimeout(() =\u003e {\n                modifiedTarget.classList.remove(\n                    SETTLING_CLASS,\n                );\n            }, settleDuration);\n        }\n    }\n}\n"},{"label":"MergeSignals","name":"MergeSignals","path":"../plugins/official/watchers/backend/sseMergeSignals","type":"WATCHER","author":"Delaney Gillilan","slug":"Merge fine grain signals store data from a server using the Datastar SDK interface","description":"Merge store data from a server using the Datastar SDK interface","icon":"material-symbols:settings-input-antenna","key":"static_library_source_plugins_official_watchers_backend_sse_merge_signals_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { InitExpressionFunction, WatcherPlugin } from \"../../../../engine\";\nimport {\n    DefaultMergeSignalsOnlyIfMissing,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { storeFromPossibleContents } from \"../../../../utils/signals\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const MergeSignals: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.MergeSignals,\n    onGlobalInit: async (ctx) =\u003e {\n        datastarSSEEventWatcher(EventTypes.MergeSignals, ({\n            signals = \"{}\",\n            onlyIfMissing: onlyIfMissingRaw =\n                `${DefaultMergeSignalsOnlyIfMissing}`,\n        }) =\u003e {\n            const onlyIfMissing = isBoolString(onlyIfMissingRaw);\n            const fnContents =\n                ` return Object.assign({...ctx.store()}, ${signals})`;\n            try {\n                const fn = new Function(\n                    \"ctx\",\n                    fnContents,\n                ) as InitExpressionFunction;\n                const possibleMergeSignals = fn(ctx);\n                const actualMergeSignals = storeFromPossibleContents(\n                    ctx.store(),\n                    possibleMergeSignals,\n                    onlyIfMissing,\n                );\n                ctx.mergeSignals(actualMergeSignals);\n                ctx.applyPlugins(document.body);\n            } catch (e) {\n                console.log(fnContents);\n                console.error(e);\n                debugger;\n            }\n        });\n    },\n};\n"},{"label":"RemoveFragments","name":"RemoveFragments","path":"../plugins/official/watchers/backend/sseRemoveFragments","type":"WATCHER","author":"Delaney Gillilan","slug":"Merge fine grain signals store data from a server using the Datastar SDK interface","description":"Merge store data from a server using the Datastar SDK interface","icon":"material-symbols:settings-input-antenna","key":"static_library_source_plugins_official_watchers_backend_sse_remove_fragments_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { WatcherPlugin } from \"../../../../engine\";\nimport {\n    DefaultFragmentsUseViewTransitions,\n    DefaultSettleDurationMs,\n    EventTypes,\n} from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { isBoolString } from \"../../../../utils/text\";\nimport {\n    docWithViewTransitionAPI,\n    supportsViewTransitions,\n} from \"../../../../utils/view-transitions\";\nimport { datastarSSEEventWatcher, SWAPPING_CLASS } from \"./sseShared\";\n\nexport const RemoveFragments: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.RemoveFragments,\n    onGlobalInit: async () =\u003e {\n        datastarSSEEventWatcher(EventTypes.RemoveFragments, ({\n            selector,\n            settleDuration: settleDurationRaw = `${DefaultSettleDurationMs}`,\n            useViewTransition: useViewTransitionRaw =\n                `${DefaultFragmentsUseViewTransitions}`,\n        }) =\u003e {\n            if (!!!selector.length) {\n                // No selector provided for remove-fragments\n                throw ERR_BAD_ARGS;\n            }\n\n            const settleDuration = parseInt(settleDurationRaw);\n            const useViewTransition = isBoolString(useViewTransitionRaw);\n            const removeTargets = document.querySelectorAll(selector);\n\n            const applyToTargets = () =\u003e {\n                for (const target of removeTargets) {\n                    target.classList.add(SWAPPING_CLASS);\n                }\n\n                setTimeout(() =\u003e {\n                    for (const target of removeTargets) {\n                        target.remove();\n                    }\n                }, settleDuration);\n            };\n\n            if (supportsViewTransitions \u0026\u0026 useViewTransition) {\n                docWithViewTransitionAPI.startViewTransition(() =\u003e\n                    applyToTargets()\n                );\n            } else {\n                applyToTargets();\n            }\n        });\n    },\n};\n"},{"label":"RemoveSignals","name":"RemoveSignals","path":"../plugins/official/watchers/backend/sseRemoveSignals","type":"WATCHER","author":"Delaney Gillilan","slug":"Merge fine grain signals store data from a server using the Datastar SDK interface","description":"Merge store data from a server using the Datastar SDK interface","icon":"material-symbols:settings-input-antenna","key":"static_library_source_plugins_official_watchers_backend_sse_remove_signals_ts","contents":"// Authors: Delaney Gillilan\n// Icon: material-symbols:settings-input-antenna\n// Slug: Merge fine grain signals store data from a server using the Datastar SDK interface\n// Description: Merge store data from a server using the Datastar SDK interface\n\nimport { EventTypes } from \"../../../../engine/consts\";\nimport { ERR_BAD_ARGS } from \"../../../../engine/errors\";\nimport { WatcherPlugin } from \"../../../../engine/types\";\nimport { datastarSSEEventWatcher } from \"./sseShared\";\n\nexport const RemoveSignals: WatcherPlugin = {\n    pluginType: \"watcher\",\n    name: EventTypes.RemoveSignals,\n    onGlobalInit: async (ctx) =\u003e {\n        datastarSSEEventWatcher(\n            EventTypes.RemoveSignals,\n            ({ paths: pathsRaw = \"\" }) =\u003e {\n                // replace all whitespace with a single space\n                pathsRaw = pathsRaw.replaceAll(/\\s+/g, \" \");\n                if (!!!pathsRaw?.length) {\n                    // No paths provided for remove-signals\n                    throw ERR_BAD_ARGS;\n                }\n                const paths = pathsRaw.split(\" \");\n                ctx.removeSignals(...paths);\n            },\n        );\n    },\n};\n"}]}}